const express = require('express');
const router = express.Router();
const { Result, User, Courses, CourseLecturers } = require('../models');
const authMiddleware = require('../middleware/authMiddleware');

// Upload / Update results (lecturer)
router.post('/upload-result', authMiddleware, async (req, res) => {
  try {
    const { courseCode, results } = req.body;
    const lecturerId = req.user.unique_id;

    // verify lecturer is assigned to this course
    const isAssigned = await CourseLecturers.findOne({
      where: { lecturerUniqueId: lecturerId, courseCode },
    });
    if (!isAssigned) return res.status(403).json({ error: 'Unauthorized: not assigned to this course' });

    // Loop over students and upload/update result
    for (const r of results) {
      const total = (r.CA || 0) + (r.Exam || 0);
      let grade = 'F';
      if (total >= 70) grade = 'A';
      else if (total >= 60) grade = 'B';
      else if (total >= 50) grade = 'C';
      else if (total >= 45) grade = 'D';
      else if (total >= 40) grade = 'E';

      await Result.upsert({
        studentUniqueId: r.studentUniqueId,
        courseCode,
        CA: r.CA,
        Exam: r.Exam,
        Total: total,
        Grade: grade,
        session: req.user.currentSession,
      });
    }

    res.status(200).json({ message: 'Results uploaded successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to upload results' });
  }
});

// Get results for a lecturerâ€™s course (students in that course)
router.get('/lecturer/course/:courseCode', authMiddleware, async (req, res) => {
  try {
    const { courseCode } = req.params;
    const lecturerId = req.user.unique_id;

    const isAssigned = await CourseLecturers.findOne({
      where: { lecturerUniqueId: lecturerId, courseCode },
    });
    if (!isAssigned) return res.status(403).json({ error: 'Unauthorized' });

    const results = await Result.findAll({
      where: { courseCode },
      include: [{ model: User, as: 'student', attributes: ['matNumber', 'firstName', 'lastName'] }],
    });

    res.status(200).json(results);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching course results' });
  }
});

// Student view their results (all sessions)
router.get('/student/results', authMiddleware, async (req, res) => {
  try {
    if (req.user.role !== 'student') return res.status(403).json({ error: 'Unauthorized' });

    const results = await Result.findAll({
      where: { studentUniqueId: req.user.unique_id },
      include: [{ model: Courses, as: 'course', attributes: ['courseTitle', 'courseCode', 'credits'] }],
      order: [['session', 'ASC']],
    });

    res.status(200).json(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to fetch results' });
  }
});

module.exports = router;




router.post("/results/publish", authMiddleware, async (req, res) => {
  const { sessionId, levelHandled } = req.body;
  const decoded = req.user;

  if (decoded.role !== "course_adviser") {
    return res.status(403).json({ error: "Only course advisers can publish results" });
  }

  await AdviserSession.update(
    { isPublished: true },
    { where: { adviserId: decoded.role_id, sessionId, levelHandled } }
  );

  return res.json({ success: true, message: "Results published successfully" });
});


router.get("/results/student", authMiddleware, async (req, res) => {
  const { session } = req.query;
  try {
    const decoded = req.user;

    if (decoded.role !== "student" || !decoded.role_id) {
      return res.status(403).json({ error: "You can only view your own results" });
    }

    const student = await Students.findOne({ where: { id: decoded.role_id } });
    if (!student) return res.status(404).json({ error: "Student not found" });

    // ðŸ”¹ Check if results for that student's level are published
    const adviserSession = await AdviserSession.findOne({
      where: {
        sessionId: session,
        levelHandled: student.Level,
        isPublished: true,
      },
    });

    if (!adviserSession) {
      return res.status(403).json({
        error: "Results for your level have not been published yet.",
      });
    }

    // ðŸ”¹ Fetch results if published
    const results = await Result.findAll({
      where: { studentUniqueId: decoded.role_id, session },
      include: [
        {
          model: Courses,
          as: "course",
          attributes: ["courseCode", "courseTitle", "credits", "level", "semester"],
        },
      ],
      order: [["session", "ASC"], ["courseCode", "ASC"]],
    });

    if (results.length === 0) {
      return res.status(404).json({ error: "No results found" });
    }

    // ðŸ§© Group by session + semester
    const grouped = results.reduce((acc, r) => {
      const sess = r.session;
      const sem = r.course.semester;
      if (!acc[sess]) acc[sess] = {};
      if (!acc[sess][sem]) acc[sess][sem] = [];
      acc[sess][sem].push({
        courseCode: r.course.courseCode,
        courseTitle: r.course.courseTitle,
        credits: r.course.credits,
        CA: r.CA,
        Exam: r.Exam,
        Total: r.Total,
        Grade: r.Grade,
      });
      return acc;
    }, {});

    return res.status(200).json({ studentId: decoded.role_id, results: grouped });
  } catch (error) {
    console.error("Student result fetch error:", error);
    return res.status(500).json({
      error: "Failed to fetch results",
      details: error.message,
    });
  }
});



router.get("/adviser/results", authMiddleware, async (req, res) => {
  try {
    const { session } = req.query;
    const decoded = req.user;

    if (decoded.role !== "course_adviser") {
      return res.status(403).json({ error: "Access denied. Adviser only." });
    }

    // Find the adviserâ€™s current session record
    const adviserSession = await AdviserSession.findOne({
      where: {
        adviserId: decoded.role_id,
        sessionId: session,
        isActiveAdviser: true,
      },
    });

    if (!adviserSession) {
      return res.status(404).json({
        error: "No active adviser session found for this adviser.",
      });
    }

    const levelHandled = adviserSession.levelHandled;

    // ðŸ”¹ Get all students under this adviser (same level)
    const students = await Students.findAll({
      where: { Level: levelHandled },
      attributes: ["id", "firstName", "lastName", "matNumber", "Level"],
    });

    if (!students.length) {
      return res.status(404).json({ error: "No students found for this level." });
    }

    // ðŸ”¹ Get all results for these students and this session
    const results = await Result.findAll({
      where: { session },
      include: [
        {
          model: Students,
          as: "student",
          attributes: ["id", "matNumber", "firstName", "lastName", "Level"],
          where: { Level: levelHandled },
        },
        {
          model: Courses,
          as: "course",
          attributes: ["courseCode", "courseTitle", "credits", "semester", "level"],
        },
      ],
      order: [["studentId", "ASC"]],
    });

    if (!results.length) {
      return res.status(404).json({ error: "No results found for this session." });
    }

    // ðŸ”¹ Organize results by student
    const formatted = {};
    for (const r of results) {
      const sid = r.student.id;
      if (!formatted[sid]) {
        formatted[sid] = {
          studentId: sid,
          name: `${r.student.firstName} ${r.student.lastName}`,
          matricNo: r.student.matNumber,
          level: r.student.Level,
          firstSem: [],
          secondSem: [],
        };
      }

      const targetArray =
        r.course.semester === "First Semester"
          ? formatted[sid].firstSem
          : formatted[sid].secondSem;

      targetArray.push({
        courseCode: r.course.courseCode,
        title: r.course.courseTitle,
        credits: r.course.credits,
        score: r.Total,
        grade: r.Grade,
      });
    }

    // ðŸ”¹ Add repeats, totals, GPA/CGPA per student
    const adviserData = Object.values(formatted).map((student) => {
      const calc = (sem) => {
        const tcf = sem.reduce((sum, c) => sum + (c.credits || 0), 0);
        const tcp = sem.reduce(
          (sum, c) =>
            sum +
            (c.credits || 0) *
              (c.grade === "A"
                ? 5
                : c.grade === "B"
                ? 4
                : c.grade === "C"
                ? 3
                : c.grade === "D"
                ? 2
                : c.grade === "E"
                ? 1
                : 0),
          0
        );
        const tcr = tcf;
        const gpa = tcf > 0 ? (tcp / tcf).toFixed(2) : "0.00";
        return { tcf, tcp, tcr, gpa };
      };

      const first = calc(student.firstSem);
      const second = calc(student.secondSem);

      const repeats = [
        ...student.firstSem.filter((c) => c.grade === "F").map((c) => c.courseCode),
        ...student.secondSem.filter((c) => c.grade === "F").map((c) => c.courseCode),
      ];

      return {
        ...student,
        repeats,
        tcf1: first.tcf,
        tcp1: first.tcp,
        tcr1: first.tcr,
        gpa1: first.gpa,
        tcf2: second.tcf,
        tcp2: second.tcp,
        tcr2: second.tcr,
        gpa2: second.gpa,
      };
    });

    return res.json({ session, level: levelHandled, results: adviserData });
  } catch (error) {
    console.error("Fetch adviser results error:", error);
    res.status(500).json({ error: "Failed to fetch adviser results.", details: error.message });
  }
});